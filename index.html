<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>送迎予定チェック</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #inputArea {
      width: 90%;
      height: 150px;
    }
    table {
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 4px 8px;
    }
    .error {
      background-color: #ffdcdc; /* エラー表示用の薄い赤色 */
    }
    .message {
      margin-top: 20px;
      font-weight: bold;
      color: red;
    }
  </style>
</head>
<body>
  <h1>送迎予定チェック</h1>
  <p>1) Excelで表をコピー (Ctrl+C) → 2) 下の枠に貼り付け (Ctrl+V) → 3)「解析」ボタン</p>
  
  <textarea id="inputArea" placeholder="ここにExcelの表を貼り付けてください"></textarea><br><br>
  <button onclick="parseData()">解析</button>

  <div id="tableContainer"></div>
  <div id="checkResult" class="message"></div>

  <script>
    // ◆◆ 時刻を数値(例: 13:10 → 1310, 13:00 → 1300)に変換するサンプル関数 ◆◆
    // Excelの入力が「1310」だったり「13:10」だったりするケースを想定。
    function parseTimeToNumber(timeStr) {
      // もし空なら NaN を返す
      if (!timeStr) return NaN;
      
      // "13:10" のようにコロンが入っていたら取り除く
      let parts = timeStr.split(":");
      if (parts.length === 2) {
        // "13:10" → 13*100 + 10 = 1310
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        return h * 100 + m;
      }
      // コロンなしの場合はそのまま数値化 (例: "1310" → 1310)
      return parseInt(timeStr, 10);
    }

    function parseData() {
      const text = document.getElementById("inputArea").value.trim();
      const resultArea = document.getElementById("checkResult");
      resultArea.textContent = ""; // メッセージ初期化

      if (!text) {
        alert("テキストが空です。Excelの表をコピーして貼り付けてください。");
        return;
      }
      
      // 改行で行に分割 (Excelコピーはタブ区切り + 行区切り)
      const lines = text.split(/\r?\n/);
      
      // テーブルHTMLを生成
      let tableHtml = "<table>";
      lines.forEach((line, rowIndex) => {
        const cols = line.split("\t");
        tableHtml += "<tr>";
        cols.forEach((col, colIndex) => {
          if (rowIndex === 0) {
            // 1行目をヘッダ扱い
            tableHtml += `<th>${col}</th>`;
          } else {
            tableHtml += `<td>${col}</td>`;
          }
        });
        tableHtml += "</tr>";
      });
      tableHtml += "</table>";
      
      // テーブル表示
      document.getElementById("tableContainer").innerHTML = tableHtml;

      // ---------- ここからチェック処理 ----------
      const table = document.querySelector("#tableContainer table");
      if (!table) return;
      
      // (1) ヘッダ行から列インデックスを特定
      const headerCells = table.rows[0].cells;
      let idxStaff   = -1; // 担当者
      let idxPickup  = -1; // お迎え時刻
      let idxArrive  = -1; // リスン到着時刻

      for (let i = 0; i < headerCells.length; i++) {
        const headerText = headerCells[i].textContent.trim();
        if (headerText === "担当" || headerText === "担当者")     idxStaff = i;
        if (headerText === "お迎え時刻")  idxPickup = i;
        if (headerText === "リスン到着" || headerText === "リスン到着時刻") idxArrive = i;
      }

      // 必須列が見つからなければエラー
      if (idxStaff === -1 || idxPickup === -1 || idxArrive === -1) {
        resultArea.textContent = "エラー: 担当者/お迎え時刻/リスン到着時刻 の列が見つかりません。";
        return;
      }

      // (2) 行データを解析して、各担当者が外出している時間帯を集計
      //     timeList = { "スタッフ名": [ {start: X, end: Y}, ... ], ... }
      const timeList = {};
      // 担当者の総数を把握したい場合があるので、ユニークな担当者名を集める
      const uniqueStaffSet = new Set();

      for (let r = 1; r < table.rows.length; r++) {
        const row = table.rows[r];
        const staffName = row.cells[idxStaff].textContent.trim();
        const pickupStr = row.cells[idxPickup].textContent.trim();
        const arriveStr = row.cells[idxArrive].textContent.trim();

        // 担当者名が空の場合もあるかもしれないのでチェック
        if (!staffName) continue;  

        uniqueStaffSet.add(staffName);

        // 時刻を数値化
        const pickupNum = parseTimeToNumber(pickupStr);
        const arriveNum = parseTimeToNumber(arriveStr);

        // 正しくパースできていれば記録
        if (!isNaN(pickupNum) && !isNaN(arriveNum)) {
          if (!timeList[staffName]) {
            timeList[staffName] = [];
          }
          timeList[staffName].push({ start: pickupNum, end: arriveNum, rowElement: row });
        }
      }

      // (3) ダブルブッキングチェック
      //     同じ担当者が重複する時間帯を持っていないか
      //     例: (start1 < end2 && start2 < end1) なら重複
      let doubleBookingError = false;
      for (const staff in timeList) {
        // start でソート
        timeList[staff].sort((a, b) => a.start - b.start);

        for (let i = 0; i < timeList[staff].length - 1; i++) {
          const current = timeList[staff][i];
          const next    = timeList[staff][i + 1];
          if (current.end > next.start) {
            // 重複発生
            doubleBookingError = true;
            // エラー表示: 背景色を変える
            current.rowElement.classList.add("error");
            next.rowElement.classList.add("error");
          }
        }
      }

      // (4) リスンが空になる時間がないかチェック
      //     すべての担当者が「外出中」になる時間帯があればNG
      //     → イベントソート(ラインスイープ)で判定
      //
      //     手順:
      //       1) 「外出開始 (start)」を +1 イベント
      //          「戻り (end)」を -1 イベントとしてリスト化
      //       2) 時間順にソートしてrunningSumを足し引き
      //       3) runningSum == 全スタッフ数 になったらリスンが空 (全員外出)
      //     ※ 必要に応じて start < end になるように (endがstartより小さい可能性は要注意)

      const events = []; // { time: number, delta: +1 or -1 }
      const allStaffCount = uniqueStaffSet.size;

      for (const staff in timeList) {
        timeList[staff].forEach(interval => {
          // もし end が start より小さいケースがあれば入れ替え(入力ミスなど)
          const s = Math.min(interval.start, interval.end);
          const e = Math.max(interval.start, interval.end);
          events.push({ time: s, delta: +1 }); // 外出開始
          events.push({ time: e, delta: -1 }); // 戻り
        });
      }

      // 時間順にソート (timeが同じ場合は -1(戻り) を先に処理すると安全)
      events.sort((a, b) => {
        if (a.time === b.time) {
          return a.delta - b.delta; 
        }
        return a.time - b.time;
      });

      let outCount = 0; // 外出中スタッフ数
      let emptyError = false;

      for (let i = 0; i < events.length; i++) {
        outCount += events[i].delta;

        if (outCount === allStaffCount) {
          // 全スタッフ外出中 (リスンが空)
          emptyError = true;
          break;
        }
      }

      // (5) 結果を画面に表示
      let msg = "";
      if (doubleBookingError) {
        msg += "【エラー】同じ担当者で重複する時間帯があります。\n";
      }
      if (emptyError) {
        msg += "【エラー】全スタッフが外出してリスンが空になる時間帯があります。\n";
      }
      if (!doubleBookingError && !emptyError) {
        msg = "OK: ダブルブッキングなし & リスンが空になる時間帯なし。";
      }

      // 改行を<br>に変換して表示
      resultArea.innerHTML = msg.replace(/\n/g, "<br>");
    }
  </script>
</body>
</html>
