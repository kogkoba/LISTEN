<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>送迎予定チェック</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #inputArea {
      width: 90%;
      height: 150px;
    }
    table {
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 4px 8px;
    }
    .error {
      background-color: #ffdcdc;
    }
    .message {
      margin-top: 20px;
      font-weight: bold;
      color: red;
    }
  </style>
</head>
<body>
  <h1>送迎予定チェック</h1>
  <p>
    1) Excelで表をコピー (Ctrl+C) → 2) 下の枠に貼り付け (Ctrl+V) → 3)「解析」ボタン
  </p>
  
  <textarea id="inputArea" placeholder="ここにExcelの表を貼り付けてください"></textarea><br><br>
  <button onclick="parseData()">解析</button>

  <div id="tableContainer"></div>
  <div id="checkResult" class="message"></div>
  <div id="absenceList"></div>

  <script>
    // 時刻文字列（例："13:10" や "1310"）を数値に変換する関数
    function parseTimeToNumber(timeStr) {
      if (!timeStr) return NaN;
      let parts = timeStr.split(":");
      if (parts.length === 2) {
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        return h * 100 + m;
      }
      return parseInt(timeStr, 10);
    }

    // 数値形式（例: 1310）を "13:10" のようにフォーマットする関数
    function formatTime(timeNum) {
      if (isNaN(timeNum)) return "不明";
      let hour = Math.floor(timeNum / 100);
      let minute = timeNum % 100;
      return hour.toString().padStart(2, '0') + ":" + minute.toString().padStart(2, '0');
    }

    function parseData() {
      const text = document.getElementById("inputArea").value.trim();
      const resultArea = document.getElementById("checkResult");
      resultArea.textContent = ""; // 結果初期化
      document.getElementById("absenceList").innerHTML = ""; // 不在一覧初期化

      if (!text) {
        alert("テキストが空です。Excelの表をコピーして貼り付けてください。");
        return;
      }
      
      // 改行で各行を分割（Excelコピーはタブ区切り＋行区切り）
      const lines = text.split(/\r?\n/);
      
      // テーブルHTMLの生成
      let tableHtml = "<table>";
      lines.forEach((line, rowIndex) => {
        const cols = line.split("\t");
        tableHtml += "<tr>";
        cols.forEach((col, colIndex) => {
          if (rowIndex === 0) {
            tableHtml += `<th>${col}</th>`;
          } else {
            tableHtml += `<td>${col}</td>`;
          }
        });
        tableHtml += "</tr>";
      });
      tableHtml += "</table>";
      
      // テーブルを画面に表示
      document.getElementById("tableContainer").innerHTML = tableHtml;

      // ---------- チェック処理 ----------
      const table = document.querySelector("#tableContainer table");
      if (!table) return;
      
      // ヘッダから各列のインデックスを特定
      const headerCells = table.rows[0].cells;
      let idxStaff  = -1; // 担当者
      let idxPickup = -1; // お迎え時刻
      let idxArrive = -1; // リスン到着時刻

      for (let i = 0; i < headerCells.length; i++) {
        const headerText = headerCells[i].textContent.trim();
        if (headerText === "担当" || headerText === "担当者")     idxStaff = i;
        if (headerText === "お迎え時刻")  idxPickup = i;
        if (headerText === "リスン到着" || headerText === "リスン到着時刻") idxArrive = i;
      }

      if (idxStaff === -1 || idxPickup === -1 || idxArrive === -1) {
        resultArea.textContent = "エラー: 担当者/お迎え時刻/リスン到着時刻 の列が見つかりません。";
        return;
      }

      // 担当者ごとの外出時間帯を集計するためのオブジェクト
      // timeList = { "スタッフ名": [ {start: 数値, end: 数値, rowElement}, ... ], ... }
      const timeList = {};
      // 担当者のユニーク数
      const uniqueStaffSet = new Set();

      for (let r = 1; r < table.rows.length; r++) {
        const row = table.rows[r];
        const staffName = row.cells[idxStaff].textContent.trim();
        const pickupStr = row.cells[idxPickup].textContent.trim();
        const arriveStr = row.cells[idxArrive].textContent.trim();

        if (!staffName) continue;  
        uniqueStaffSet.add(staffName);

        const pickupNum = parseTimeToNumber(pickupStr);
        const arriveNum = parseTimeToNumber(arriveStr);

        if (!isNaN(pickupNum) && !isNaN(arriveNum)) {
          if (!timeList[staffName]) {
            timeList[staffName] = [];
          }
          timeList[staffName].push({ start: pickupNum, end: arriveNum, rowElement: row });
        }
      }

      // (1) ダブルブッキングチェック（同じ担当者で重複する時間帯があるか）
      let doubleBookingError = false;
      for (const staff in timeList) {
        timeList[staff].sort((a, b) => a.start - b.start);
        for (let i = 0; i < timeList[staff].length - 1; i++) {
          const current = timeList[staff][i];
          const next    = timeList[staff][i + 1];
          if (current.end > next.start) {
            doubleBookingError = true;
            current.rowElement.classList.add("error");
            next.rowElement.classList.add("error");
          }
        }
      }

      // (2) リスンが空になる（全スタッフが外出中）時間のチェック
      const events = [];
      const allStaffCount = uniqueStaffSet.size;
      for (const staff in timeList) {
        timeList[staff].forEach(interval => {
          // 万が一、endがstartより小さい場合は順序入れ替え
          const s = Math.min(interval.start, interval.end);
          const e = Math.max(interval.start, interval.end);
          events.push({ time: s, delta: +1 });
          events.push({ time: e, delta: -1 });
        });
      }
      events.sort((a, b) => {
        if (a.time === b.time) {
          return a.delta - b.delta; 
        }
        return a.time - b.time;
      });
      let outCount = 0;
      let emptyError = false;
      for (let i = 0; i < events.length; i++) {
        outCount += events[i].delta;
        if (outCount === allStaffCount) {
          emptyError = true;
          break;
        }
      }

      // (3) 結果メッセージ表示
      let msg = "";
      if (doubleBookingError) {
        msg += "【エラー】同じ担当者で重複する時間帯があります。\n";
      }
      if (emptyError) {
        msg += "【エラー】全スタッフが外出してリスンが空になる時間帯があります。\n";
      }
      if (!doubleBookingError && !emptyError) {
        msg = "OK: ダブルブッキングなし & リスンが空になる時間帯なし。";
      }
      resultArea.innerHTML = msg.replace(/\n/g, "<br>");

      // (4) スタッフごとの不在時間帯のリスト表示
      let absenceHtml = "<h2>スタッフ別不在時間一覧</h2><ul>";
      for (const staff in timeList) {
        // 既にソート済みなので、各スタッフの時間帯をそのまま表示
        let intervals = timeList[staff].map(interval => {
          return formatTime(interval.start) + " ～ " + formatTime(interval.end);
        });
        absenceHtml += `<li>${staff}: ${intervals.join(", ")}</li>`;
      }
      absenceHtml += "</ul>";
      document.getElementById("absenceList").innerHTML = absenceHtml;
    }
  </script>
</body>
</html>